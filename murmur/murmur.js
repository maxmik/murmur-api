// **********************************************************************
//
// Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.0
//
// <auto-generated>
//
// Generated from file `Murmur.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var Slice = Ice.Slice;

    var Murmur = __M.module("Murmur");
    Slice.defineSequence(Murmur, "NetAddressHelper", "Ice.ByteHelper", true);

    /**
     * A connected user.
     **/
    Murmur.User = Slice.defineStruct(
        function(session, userid, mute, deaf, suppress, prioritySpeaker, selfMute, selfDeaf, recording, channel, name, onlinesecs, bytespersec, version, release, os, osversion, identity, context, comment, address, tcponly, idlesecs, udpPing, tcpPing)
        {
            this.session = session !== undefined ? session : 0;
            this.userid = userid !== undefined ? userid : 0;
            this.mute = mute !== undefined ? mute : false;
            this.deaf = deaf !== undefined ? deaf : false;
            this.suppress = suppress !== undefined ? suppress : false;
            this.prioritySpeaker = prioritySpeaker !== undefined ? prioritySpeaker : false;
            this.selfMute = selfMute !== undefined ? selfMute : false;
            this.selfDeaf = selfDeaf !== undefined ? selfDeaf : false;
            this.recording = recording !== undefined ? recording : false;
            this.channel = channel !== undefined ? channel : 0;
            this.name = name !== undefined ? name : "";
            this.onlinesecs = onlinesecs !== undefined ? onlinesecs : 0;
            this.bytespersec = bytespersec !== undefined ? bytespersec : 0;
            this.version = version !== undefined ? version : 0;
            this.release = release !== undefined ? release : "";
            this.os = os !== undefined ? os : "";
            this.osversion = osversion !== undefined ? osversion : "";
            this.identity = identity !== undefined ? identity : "";
            this.context = context !== undefined ? context : "";
            this.comment = comment !== undefined ? comment : "";
            this.address = address !== undefined ? address : null;
            this.tcponly = tcponly !== undefined ? tcponly : false;
            this.idlesecs = idlesecs !== undefined ? idlesecs : 0;
            this.udpPing = udpPing !== undefined ? udpPing : 0.0;
            this.tcpPing = tcpPing !== undefined ? tcpPing : 0.0;
        },
        false,
        function(__os)
        {
            __os.writeInt(this.session);
            __os.writeInt(this.userid);
            __os.writeBool(this.mute);
            __os.writeBool(this.deaf);
            __os.writeBool(this.suppress);
            __os.writeBool(this.prioritySpeaker);
            __os.writeBool(this.selfMute);
            __os.writeBool(this.selfDeaf);
            __os.writeBool(this.recording);
            __os.writeInt(this.channel);
            __os.writeString(this.name);
            __os.writeInt(this.onlinesecs);
            __os.writeInt(this.bytespersec);
            __os.writeInt(this.version);
            __os.writeString(this.release);
            __os.writeString(this.os);
            __os.writeString(this.osversion);
            __os.writeString(this.identity);
            __os.writeString(this.context);
            __os.writeString(this.comment);
            Murmur.NetAddressHelper.write(__os, this.address);
            __os.writeBool(this.tcponly);
            __os.writeInt(this.idlesecs);
            __os.writeFloat(this.udpPing);
            __os.writeFloat(this.tcpPing);
        },
        function(__is)
        {
            this.session = __is.readInt();
            this.userid = __is.readInt();
            this.mute = __is.readBool();
            this.deaf = __is.readBool();
            this.suppress = __is.readBool();
            this.prioritySpeaker = __is.readBool();
            this.selfMute = __is.readBool();
            this.selfDeaf = __is.readBool();
            this.recording = __is.readBool();
            this.channel = __is.readInt();
            this.name = __is.readString();
            this.onlinesecs = __is.readInt();
            this.bytespersec = __is.readInt();
            this.version = __is.readInt();
            this.release = __is.readString();
            this.os = __is.readString();
            this.osversion = __is.readString();
            this.identity = __is.readString();
            this.context = __is.readString();
            this.comment = __is.readString();
            this.address = Murmur.NetAddressHelper.read(__is);
            this.tcponly = __is.readBool();
            this.idlesecs = __is.readInt();
            this.udpPing = __is.readFloat();
            this.tcpPing = __is.readFloat();
        },
        52, 
        false);
    Slice.defineSequence(Murmur, "IntListHelper", "Ice.IntHelper", true);

    /**
     * A text message between users.
     **/
    Murmur.TextMessage = Slice.defineStruct(
        function(sessions, channels, trees, text)
        {
            this.sessions = sessions !== undefined ? sessions : null;
            this.channels = channels !== undefined ? channels : null;
            this.trees = trees !== undefined ? trees : null;
            this.text = text !== undefined ? text : "";
        },
        true,
        function(__os)
        {
            Murmur.IntListHelper.write(__os, this.sessions);
            Murmur.IntListHelper.write(__os, this.channels);
            Murmur.IntListHelper.write(__os, this.trees);
            __os.writeString(this.text);
        },
        function(__is)
        {
            this.sessions = Murmur.IntListHelper.read(__is);
            this.channels = Murmur.IntListHelper.read(__is);
            this.trees = Murmur.IntListHelper.read(__is);
            this.text = __is.readString();
        },
        4, 
        false);

    /**
     * A channel.
     **/
    Murmur.Channel = Slice.defineStruct(
        function(id, name, parent, links, description, temporary, position)
        {
            this.id = id !== undefined ? id : 0;
            this.name = name !== undefined ? name : "";
            this.parent = parent !== undefined ? parent : 0;
            this.links = links !== undefined ? links : null;
            this.description = description !== undefined ? description : "";
            this.temporary = temporary !== undefined ? temporary : false;
            this.position = position !== undefined ? position : 0;
        },
        true,
        function(__os)
        {
            __os.writeInt(this.id);
            __os.writeString(this.name);
            __os.writeInt(this.parent);
            Murmur.IntListHelper.write(__os, this.links);
            __os.writeString(this.description);
            __os.writeBool(this.temporary);
            __os.writeInt(this.position);
        },
        function(__is)
        {
            this.id = __is.readInt();
            this.name = __is.readString();
            this.parent = __is.readInt();
            this.links = Murmur.IntListHelper.read(__is);
            this.description = __is.readString();
            this.temporary = __is.readBool();
            this.position = __is.readInt();
        },
        16, 
        false);

    /**
     * A group. Groups are defined per channel, and can inherit members from parent channels.
     **/
    Murmur.Group = Slice.defineStruct(
        function(name, inherited, inherit, inheritable, add, remove, members)
        {
            this.name = name !== undefined ? name : "";
            this.inherited = inherited !== undefined ? inherited : false;
            this.inherit = inherit !== undefined ? inherit : false;
            this.inheritable = inheritable !== undefined ? inheritable : false;
            this.add = add !== undefined ? add : null;
            this.remove = remove !== undefined ? remove : null;
            this.members = members !== undefined ? members : null;
        },
        true,
        function(__os)
        {
            __os.writeString(this.name);
            __os.writeBool(this.inherited);
            __os.writeBool(this.inherit);
            __os.writeBool(this.inheritable);
            Murmur.IntListHelper.write(__os, this.add);
            Murmur.IntListHelper.write(__os, this.remove);
            Murmur.IntListHelper.write(__os, this.members);
        },
        function(__is)
        {
            this.name = __is.readString();
            this.inherited = __is.readBool();
            this.inherit = __is.readBool();
            this.inheritable = __is.readBool();
            this.add = Murmur.IntListHelper.read(__is);
            this.remove = Murmur.IntListHelper.read(__is);
            this.members = Murmur.IntListHelper.read(__is);
        },
        7, 
        false);

    Object.defineProperty(Murmur, 'PermissionWrite', {
        value: 1
    });

    Object.defineProperty(Murmur, 'PermissionTraverse', {
        value: 2
    });

    Object.defineProperty(Murmur, 'PermissionEnter', {
        value: 4
    });

    Object.defineProperty(Murmur, 'PermissionSpeak', {
        value: 8
    });

    Object.defineProperty(Murmur, 'PermissionWhisper', {
        value: 256
    });

    Object.defineProperty(Murmur, 'PermissionMuteDeafen', {
        value: 16
    });

    Object.defineProperty(Murmur, 'PermissionMove', {
        value: 32
    });

    Object.defineProperty(Murmur, 'PermissionMakeChannel', {
        value: 64
    });

    Object.defineProperty(Murmur, 'PermissionMakeTempChannel', {
        value: 1024
    });

    Object.defineProperty(Murmur, 'PermissionLinkChannel', {
        value: 128
    });

    Object.defineProperty(Murmur, 'PermissionTextMessage', {
        value: 512
    });

    Object.defineProperty(Murmur, 'PermissionKick', {
        value: 65536
    });

    Object.defineProperty(Murmur, 'PermissionBan', {
        value: 131072
    });

    Object.defineProperty(Murmur, 'PermissionRegister', {
        value: 262144
    });

    Object.defineProperty(Murmur, 'PermissionRegisterSelf', {
        value: 524288
    });

    /**
     * Access Control List for a channel. ACLs are defined per channel, and can be inherited from parent channels.
     **/
    Murmur.ACL = Slice.defineStruct(
        function(applyHere, applySubs, inherited, userid, group, allow, deny)
        {
            this.applyHere = applyHere !== undefined ? applyHere : false;
            this.applySubs = applySubs !== undefined ? applySubs : false;
            this.inherited = inherited !== undefined ? inherited : false;
            this.userid = userid !== undefined ? userid : 0;
            this.group = group !== undefined ? group : "";
            this.allow = allow !== undefined ? allow : 0;
            this.deny = deny !== undefined ? deny : 0;
        },
        true,
        function(__os)
        {
            __os.writeBool(this.applyHere);
            __os.writeBool(this.applySubs);
            __os.writeBool(this.inherited);
            __os.writeInt(this.userid);
            __os.writeString(this.group);
            __os.writeInt(this.allow);
            __os.writeInt(this.deny);
        },
        function(__is)
        {
            this.applyHere = __is.readBool();
            this.applySubs = __is.readBool();
            this.inherited = __is.readBool();
            this.userid = __is.readInt();
            this.group = __is.readString();
            this.allow = __is.readInt();
            this.deny = __is.readInt();
        },
        16, 
        false);

    /**
     * A single ip mask for a ban.
     **/
    Murmur.Ban = Slice.defineStruct(
        function(address, bits, name, hash, reason, start, duration)
        {
            this.address = address !== undefined ? address : null;
            this.bits = bits !== undefined ? bits : 0;
            this.name = name !== undefined ? name : "";
            this.hash = hash !== undefined ? hash : "";
            this.reason = reason !== undefined ? reason : "";
            this.start = start !== undefined ? start : 0;
            this.duration = duration !== undefined ? duration : 0;
        },
        true,
        function(__os)
        {
            Murmur.NetAddressHelper.write(__os, this.address);
            __os.writeInt(this.bits);
            __os.writeString(this.name);
            __os.writeString(this.hash);
            __os.writeString(this.reason);
            __os.writeInt(this.start);
            __os.writeInt(this.duration);
        },
        function(__is)
        {
            this.address = Murmur.NetAddressHelper.read(__is);
            this.bits = __is.readInt();
            this.name = __is.readString();
            this.hash = __is.readString();
            this.reason = __is.readString();
            this.start = __is.readInt();
            this.duration = __is.readInt();
        },
        16, 
        false);

    /**
     * A entry in the log.
     **/
    Murmur.LogEntry = Slice.defineStruct(
        function(timestamp, txt)
        {
            this.timestamp = timestamp !== undefined ? timestamp : 0;
            this.txt = txt !== undefined ? txt : "";
        },
        true,
        function(__os)
        {
            __os.writeInt(this.timestamp);
            __os.writeString(this.txt);
        },
        function(__is)
        {
            this.timestamp = __is.readInt();
            this.txt = __is.readString();
        },
        5, 
        false);
    Slice.defineSequence(Murmur, "TreeListHelper", "Ice.ObjectHelper", false, "Murmur.Tree");

    Murmur.ChannelInfo = Slice.defineEnum([
        ['ChannelDescription', 0], ['ChannelPosition', 1]]);

    Murmur.UserInfo = Slice.defineEnum([
        ['UserName', 0], ['UserEmail', 1], ['UserComment', 2], ['UserHash', 3], ['UserPassword', 4],
        ['UserLastActive', 5]]);
    Slice.defineDictionary(Murmur, "UserMap", "UserMapHelper", "Ice.IntHelper", "Murmur.User", false, undefined, undefined, Ice.HashMap.compareEquals);
    Slice.defineDictionary(Murmur, "ChannelMap", "ChannelMapHelper", "Ice.IntHelper", "Murmur.Channel", false, undefined, undefined, Ice.HashMap.compareEquals);
    Slice.defineSequence(Murmur, "ChannelListHelper", "Murmur.Channel", false);
    Slice.defineSequence(Murmur, "UserListHelper", "Murmur.User", false);
    Slice.defineSequence(Murmur, "GroupListHelper", "Murmur.Group", false);
    Slice.defineSequence(Murmur, "ACLListHelper", "Murmur.ACL", false);
    Slice.defineSequence(Murmur, "LogListHelper", "Murmur.LogEntry", false);
    Slice.defineSequence(Murmur, "BanListHelper", "Murmur.Ban", false);
    Slice.defineSequence(Murmur, "IdListHelper", "Ice.IntHelper", true);
    Slice.defineSequence(Murmur, "NameListHelper", "Ice.StringHelper", false);
    Slice.defineDictionary(Murmur, "NameMap", "NameMapHelper", "Ice.IntHelper", "Ice.StringHelper", false, undefined, undefined);
    Slice.defineDictionary(Murmur, "IdMap", "IdMapHelper", "Ice.StringHelper", "Ice.IntHelper", false, undefined, undefined);
    Slice.defineSequence(Murmur, "TextureHelper", "Ice.ByteHelper", true);
    Slice.defineDictionary(Murmur, "ConfigMap", "ConfigMapHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);
    Slice.defineSequence(Murmur, "GroupNameListHelper", "Ice.StringHelper", false);
    Slice.defineSequence(Murmur, "CertificateDerHelper", "Ice.ByteHelper", true);
    Slice.defineSequence(Murmur, "CertificateListHelper", "Murmur.CertificateDerHelper", false);
    Slice.defineDictionary(Murmur, "UserInfoMap", "UserInfoMapHelper", "Murmur.UserInfo.__helper", "Ice.StringHelper", false, undefined, undefined);

    /**
     * User and subchannel state. Read-only.
     **/
    Murmur.Tree = Slice.defineObject(
        function(c, children, users)
        {
            Ice.Object.call(this);
            this.c = c !== undefined ? c : new Murmur.Channel();
            this.children = children !== undefined ? children : null;
            this.users = users !== undefined ? users : null;
        },
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::Murmur::Tree"
        ],
        -1,
        function(__os)
        {
            Murmur.Channel.write(__os, this.c);
            Murmur.TreeListHelper.write(__os, this.children);
            Murmur.UserListHelper.write(__os, this.users);
        },
        function(__is)
        {
            this.c = Murmur.Channel.read(__is, this.c);
            this.children = Murmur.TreeListHelper.read(__is);
            this.users = Murmur.UserListHelper.read(__is);
        },
        false);

    Murmur.TreePrx = Slice.defineProxy(Ice.ObjectPrx, Murmur.Tree.ice_staticId, undefined);

    Slice.defineOperations(Murmur.Tree, Murmur.TreePrx);

    Murmur.MurmurException = Slice.defineUserException(
        function(_cause)
        {
            Ice.UserException.call(this, _cause);
        },
        Ice.UserException,
        "Murmur::MurmurException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown when you specify an invalid session. This may happen if the user has disconnected since your last call to {@link Server.getUsers}. See {@link User.session}
     **/
    Murmur.InvalidSessionException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::InvalidSessionException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown when you specify an invalid channel id. This may happen if the channel was removed by another provess. It can also be thrown if you try to add an invalid channel.
     **/
    Murmur.InvalidChannelException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::InvalidChannelException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown when you try to do an operation on a server that does not exist. This may happen if someone has removed the server.
     **/
    Murmur.InvalidServerException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::InvalidServerException",
        undefined, undefined,
        false,
        false);

    /**
     * This happens if you try to fetch user or channel state on a stopped server, if you try to stop an already stopped server or start an already started server.
     **/
    Murmur.ServerBootedException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::ServerBootedException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown if {@link Server.start} fails, and should generally be the cause for some concern.
     **/
    Murmur.ServerFailureException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::ServerFailureException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown when you specify an invalid userid.
     **/
    Murmur.InvalidUserException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::InvalidUserException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown when you try to set an invalid texture.
     **/
    Murmur.InvalidTextureException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::InvalidTextureException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown when you supply an invalid callback.
     **/
    Murmur.InvalidCallbackException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::InvalidCallbackException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown when you supply the wrong secret in the calling context.
     **/
    Murmur.InvalidSecretException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::InvalidSecretException",
        undefined, undefined,
        false,
        false);

    /**
     * This is thrown when the channel operation would excede the channel nesting limit
     **/
    Murmur.NestingLimitException = Slice.defineUserException(
        function(_cause)
        {
            Murmur.MurmurException.call(this, _cause);
        },
        Murmur.MurmurException,
        "Murmur::NestingLimitException",
        undefined, undefined,
        false,
        false);

    /**
     * Callback interface for servers. You can supply an implementation of this to receive notification
     * messages from the server.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     * Note that callbacks are removed when a server is stopped, so you should have a callback for
     * {@link MetaCallback.started} which calls {@link Server.addCallback}.
     * @see MetaCallback
     * @see Server.addCallback
     **/
    Murmur.ServerCallback = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::Murmur::ServerCallback"
        ],
        -1, undefined, undefined, false);

    Murmur.ServerCallbackPrx = Slice.defineProxy(Ice.ObjectPrx, Murmur.ServerCallback.ice_staticId, undefined);

    Slice.defineOperations(Murmur.ServerCallback, Murmur.ServerCallbackPrx,
    {
        "userConnected": [, 2, 2, , , , [[Murmur.User]], , , , ],
        "userDisconnected": [, 2, 2, , , , [[Murmur.User]], , , , ],
        "userStateChanged": [, 2, 2, , , , [[Murmur.User]], , , , ],
        "userTextMessage": [, 2, 2, , , , [[Murmur.User], [Murmur.TextMessage]], , , , ],
        "channelCreated": [, 2, 2, , , , [[Murmur.Channel]], , , , ],
        "channelRemoved": [, 2, 2, , , , [[Murmur.Channel]], , , , ],
        "channelStateChanged": [, 2, 2, , , , [[Murmur.Channel]], , , , ]
    });

    Object.defineProperty(Murmur, 'ContextServer', {
        value: 1
    });

    Object.defineProperty(Murmur, 'ContextChannel', {
        value: 2
    });

    Object.defineProperty(Murmur, 'ContextUser', {
        value: 4
    });

    /**
     * Callback interface for context actions. You need to supply one of these for {@link Server.addContext}. 
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     **/
    Murmur.ServerContextCallback = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::Murmur::ServerContextCallback"
        ],
        -1, undefined, undefined, false);

    Murmur.ServerContextCallbackPrx = Slice.defineProxy(Ice.ObjectPrx, Murmur.ServerContextCallback.ice_staticId, undefined);

    Slice.defineOperations(Murmur.ServerContextCallback, Murmur.ServerContextCallbackPrx,
    {
        "contextAction": [, 2, 2, , , , [[7], [Murmur.User], [3], [3]], , , , ]
    });

    /**
     * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
     * synchronously. If the response lags, the entire murmur server will lag.
     * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
     * deadlock the server.
     **/
    Murmur.ServerAuthenticator = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::Murmur::ServerAuthenticator"
        ],
        -1, undefined, undefined, false);

    Murmur.ServerAuthenticatorPrx = Slice.defineProxy(Ice.ObjectPrx, Murmur.ServerAuthenticator.ice_staticId, undefined);

    Slice.defineOperations(Murmur.ServerAuthenticator, Murmur.ServerAuthenticatorPrx,
    {
        "authenticate": [, 2, 2, , , [3], [[7], [7], ["Murmur.CertificateListHelper"], [7], [1]], [[7], ["Murmur.GroupNameListHelper"]], , , ],
        "getInfo": [, 2, 2, , , [1], [[3]], [["Murmur.UserInfoMapHelper"]], , , ],
        "nameToId": [, 2, 2, , , [3], [[7]], , , , ],
        "idToName": [, 2, 2, , , [7], [[3]], , , , ],
        "idToTexture": [, 2, 2, , , ["Murmur.TextureHelper"], [[3]], , , , ]
    });

    /**
     * Callback interface for server authentication and registration. This allows you to support both authentication
     * and account updating.
     * You do not need to implement this if all you want is authentication, you only need this if other scripts
     * connected to the same server calls e.g. {@link Server.setTexture}.
     * Almost all of these methods support fall through, meaning murmur should continue the operation against its
     * own database.
     **/
    Murmur.ServerUpdatingAuthenticator = Slice.defineObject(
        undefined,
        Ice.Object,
        [
            Murmur.ServerAuthenticator
        ], 2,
        [
            "::Ice::Object",
            "::Murmur::ServerAuthenticator",
            "::Murmur::ServerUpdatingAuthenticator"
        ],
        -1, undefined, undefined, false);

    Murmur.ServerUpdatingAuthenticatorPrx = Slice.defineProxy(Ice.ObjectPrx, Murmur.ServerUpdatingAuthenticator.ice_staticId, [
        Murmur.ServerAuthenticatorPrx]);

    Slice.defineOperations(Murmur.ServerUpdatingAuthenticator, Murmur.ServerUpdatingAuthenticatorPrx,
    {
        "registerUser": [, , , , , [3], [["Murmur.UserInfoMapHelper"]], , , , ],
        "unregisterUser": [, , , , , [3], [[3]], , , , ],
        "getRegisteredUsers": [, 2, 2, , , ["Murmur.NameMapHelper"], [[7]], , , , ],
        "setInfo": [, 2, 2, , , [3], [[3], ["Murmur.UserInfoMapHelper"]], , , , ],
        "setTexture": [, 2, 2, , , [3], [[3], ["Murmur.TextureHelper"]], , , , ]
    });

    /**
     * Per-server interface. This includes all methods for configuring and altering
     * the state of a single virtual server. You can retrieve a pointer to this interface
     * from one of the methods in {@link Meta}.
     **/
    Murmur.Server = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::Murmur::Server"
        ],
        -1, undefined, undefined, false);

    Murmur.ServerPrx = Slice.defineProxy(Ice.ObjectPrx, Murmur.Server.ice_staticId, undefined);

    Slice.defineOperations(Murmur.Server, Murmur.ServerPrx,
    {
        "isRunning": [, 2, 2, 1, , [1], , , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "start": [, , , 1, , , , , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException,
            Murmur.ServerFailureException
        ], , ],
        "stop": [, , , 1, , , , , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "delete": ["_delete", , , 1, , , , , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "id": [, 2, 2, 1, , [3], , , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "addCallback": [, , , 1, , , [["Murmur.ServerCallbackPrx"]], , 
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "removeCallback": [, , , 1, , , [["Murmur.ServerCallbackPrx"]], , 
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "setAuthenticator": [, , , 1, , , [["Murmur.ServerAuthenticatorPrx"]], , 
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getConf": [, 2, 2, 1, , [7], [[7]], , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "getAllConf": [, 2, 2, 1, , ["Murmur.ConfigMapHelper"], , , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "setConf": [, 2, 2, 1, , , [[7], [7]], , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "setSuperuserPassword": [, 2, 2, 1, , , [[7]], , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "getLog": [, 2, 2, 1, , ["Murmur.LogListHelper"], [[3], [3]], , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "getLogLen": [, 2, 2, 1, , [3], , , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "getUsers": [, 2, 2, 1, , ["Murmur.UserMapHelper"], , , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getChannels": [, 2, 2, 1, , ["Murmur.ChannelMapHelper"], , , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getCertificateList": [, 2, 2, 1, , ["Murmur.CertificateListHelper"], [[3]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "getTree": [, 2, 2, 1, , ["Murmur.Tree", true], , , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , true],
        "getBans": [, 2, 2, 1, , ["Murmur.BanListHelper"], , , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "setBans": [, 2, 2, 1, , , [["Murmur.BanListHelper"]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "kickUser": [, , , 1, , , [[3], [7]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "getState": [, 2, 2, 1, , [Murmur.User], [[3]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "setState": [, 2, 2, 1, , , [[Murmur.User]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "sendMessage": [, , , 1, , , [[3], [7]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "hasPermission": [, , , 1, , [1], [[3], [3], [3]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "effectivePermissions": [, 2, 2, 1, , [3], [[3], [3]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "addContextCallback": [, , , 1, , , [[3], [7], [7], ["Murmur.ServerContextCallbackPrx"], [3]], , 
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "removeContextCallback": [, , , 1, , , [["Murmur.ServerContextCallbackPrx"]], , 
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getChannelState": [, 2, 2, 1, , [Murmur.Channel], [[3]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "setChannelState": [, 2, 2, 1, , , [[Murmur.Channel]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.NestingLimitException,
            Murmur.ServerBootedException
        ], , ],
        "removeChannel": [, , , 1, , , [[3]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "addChannel": [, , , 1, , [3], [[7], [3]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.NestingLimitException,
            Murmur.ServerBootedException
        ], , ],
        "sendMessageChannel": [, , , 1, , , [[3], [1], [7]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getACL": [, 2, 2, 1, , , [[3]], [["Murmur.ACLListHelper"], ["Murmur.GroupListHelper"], [1]], 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "setACL": [, 2, 2, 1, , , [[3], ["Murmur.ACLListHelper"], ["Murmur.GroupListHelper"], [1]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "addUserToGroup": [, 2, 2, 1, , , [[3], [3], [7]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "removeUserFromGroup": [, 2, 2, 1, , , [[3], [3], [7]], , 
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "redirectWhisperGroup": [, 2, 2, 1, , , [[3], [7], [7]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "getUserNames": [, 2, 2, 1, , ["Murmur.NameMapHelper"], [["Murmur.IdListHelper"]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getUserIds": [, 2, 2, 1, , ["Murmur.IdMapHelper"], [["Murmur.NameListHelper"]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "registerUser": [, , , 1, , [3], [["Murmur.UserInfoMapHelper"]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "unregisterUser": [, , , 1, , , [[3]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "updateRegistration": [, 2, 2, 1, , , [[3], ["Murmur.UserInfoMapHelper"]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "getRegistration": [, 2, 2, 1, , ["Murmur.UserInfoMapHelper"], [[3]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "getRegisteredUsers": [, 2, 2, 1, , ["Murmur.NameMapHelper"], [[7]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "verifyPassword": [, 2, 2, 1, , [3], [[7], [7]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getTexture": [, 2, 2, 1, , ["Murmur.TextureHelper"], [[3]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "setTexture": [, 2, 2, 1, , , [[3], ["Murmur.TextureHelper"]], , 
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidTextureException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "getUptime": [, 2, 2, 1, , [3], , , 
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ]
    });

    /**
     * Callback interface for Meta. You can supply an implementation of this to receive notifications
     * when servers are stopped or started.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     * @see ServerCallback
     * @see Meta.addCallback
     **/
    Murmur.MetaCallback = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::Murmur::MetaCallback"
        ],
        -1, undefined, undefined, false);

    Murmur.MetaCallbackPrx = Slice.defineProxy(Ice.ObjectPrx, Murmur.MetaCallback.ice_staticId, undefined);

    Slice.defineOperations(Murmur.MetaCallback, Murmur.MetaCallbackPrx,
    {
        "started": [, , , , , , [["Murmur.ServerPrx"]], , , , ],
        "stopped": [, , , , , , [["Murmur.ServerPrx"]], , , , ]
    });
    Slice.defineSequence(Murmur, "ServerListHelper", "Murmur.ServerPrx", false);

    /**
     * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
     **/
    Murmur.Meta = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::Murmur::Meta"
        ],
        -1, undefined, undefined, false);

    Murmur.MetaPrx = Slice.defineProxy(Ice.ObjectPrx, Murmur.Meta.ice_staticId, undefined);

    Slice.defineOperations(Murmur.Meta, Murmur.MetaPrx,
    {
        "getServer": [, 2, 2, 1, , ["Murmur.ServerPrx"], [[3]], , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "newServer": [, , , 1, , ["Murmur.ServerPrx"], , , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "getBootedServers": [, 2, 2, 1, , ["Murmur.ServerListHelper"], , , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "getAllServers": [, 2, 2, 1, , ["Murmur.ServerListHelper"], , , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "getDefaultConf": [, 2, 2, 1, , ["Murmur.ConfigMapHelper"], , , 
        [
            Murmur.InvalidSecretException
        ], , ],
        "getVersion": [, 2, 2, 1, , , , [[3], [3], [3], [7]], , , ],
        "addCallback": [, , , 1, , , [["Murmur.MetaCallbackPrx"]], , 
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException
        ], , ],
        "removeCallback": [, , , 1, , , [["Murmur.MetaCallbackPrx"]], , 
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException
        ], , ],
        "getUptime": [, 2, 2, 1, , [3], , , , , ],
        "getSlice": [, 2, 2, 1, , [7], , , , , ],
        "getSliceChecksums": [, 2, 2, 1, , ["Ice.SliceChecksumDictHelper"], , , , , ]
    });
    exports.Murmur = Murmur;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : window.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : window));
